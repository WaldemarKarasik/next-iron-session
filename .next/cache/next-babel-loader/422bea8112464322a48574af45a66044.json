{"ast":null,"code":"import withSession from \"../../lib/session\";\nimport mongoose from \"mongoose\";\nconst ProductSchema = new mongoose.Schema({\n  name: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  category: {\n    type: mongoose.SchemaTypes.ObjectId,\n    ref: \"Category\"\n  },\n  brand: String,\n  image: String,\n  price: Number,\n  rating: Number,\n  numReviews: Number,\n  countInStock: Number\n});\nmongoose.connect(\"mongodb+srv://komsomolradio:irkytsk87@cluster0.melez.gcp.mongodb.net/vercel-amazemo?retryWrites=true&w=majority\", {\n  useNewUrlParser: true,\n  useUnifiedTopology: true,\n  useFindAndModify: false\n});\nlet Product;\n\ntry {\n  // Trying to get the existing model to avoid OverwriteModelError\n  Product = mongoose.model(\"Product\");\n} catch {\n  Product = mongoose.model(\"Product\", ProductSchema);\n}\n\nexport default withSession(async (req, res) => {\n  if (req.query.id) {\n    // const product = data.products.find((x) => x._id == req.query.id);\n    const product = await Product.findOne({\n      _id: req.query.id\n    }).lean();\n\n    if (product) {\n      return res.json(product);\n    }\n  }\n\n  const products = await Product.find().populate(\"category\").lean();\n  return res.json(products);\n});","map":{"version":3,"sources":["C:/Users/daniel/Documents/react/next-iron-session/pages/api/products.ts"],"names":["withSession","mongoose","ProductSchema","Schema","name","type","String","required","unique","category","SchemaTypes","ObjectId","ref","brand","image","price","Number","rating","numReviews","countInStock","connect","useNewUrlParser","useUnifiedTopology","useFindAndModify","Product","model","req","res","query","id","product","findOne","_id","lean","json","products","find","populate"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,mBAAxB;AAEA,OAAOC,QAAP,MAAqB,UAArB;AAEA,MAAMC,aAAa,GAAG,IAAID,QAAQ,CAACE,MAAb,CAAoB;AACxCC,EAAAA,IAAI,EAAE;AAAEC,IAAAA,IAAI,EAAEC,MAAR;AAAgBC,IAAAA,QAAQ,EAAE,IAA1B;AAAgCC,IAAAA,MAAM,EAAE;AAAxC,GADkC;AAExCC,EAAAA,QAAQ,EAAE;AAAEJ,IAAAA,IAAI,EAAEJ,QAAQ,CAACS,WAAT,CAAqBC,QAA7B;AAAuCC,IAAAA,GAAG,EAAE;AAA5C,GAF8B;AAGxCC,EAAAA,KAAK,EAAEP,MAHiC;AAIxCQ,EAAAA,KAAK,EAAER,MAJiC;AAKxCS,EAAAA,KAAK,EAAEC,MALiC;AAMxCC,EAAAA,MAAM,EAAED,MANgC;AAOxCE,EAAAA,UAAU,EAAEF,MAP4B;AAQxCG,EAAAA,YAAY,EAAEH;AAR0B,CAApB,CAAtB;AAWAf,QAAQ,CAACmB,OAAT,CACE,iHADF,EAEE;AACEC,EAAAA,eAAe,EAAE,IADnB;AAEEC,EAAAA,kBAAkB,EAAE,IAFtB;AAGEC,EAAAA,gBAAgB,EAAE;AAHpB,CAFF;AASA,IAAIC,OAAJ;;AAEA,IAAI;AACF;AAEAA,EAAAA,OAAO,GAAGvB,QAAQ,CAACwB,KAAT,CAAe,SAAf,CAAV;AACD,CAJD,CAIE,MAAM;AACND,EAAAA,OAAO,GAAGvB,QAAQ,CAACwB,KAAT,CAAe,SAAf,EAA0BvB,aAA1B,CAAV;AACD;;AAED,eAAeF,WAAW,CAAC,OAAO0B,GAAP,EAAYC,GAAZ,KAAoB;AAC7C,MAAID,GAAG,CAACE,KAAJ,CAAUC,EAAd,EAAkB;AAChB;AACA,UAAMC,OAAO,GAAG,MAAMN,OAAO,CAACO,OAAR,CAAgB;AAAEC,MAAAA,GAAG,EAAEN,GAAG,CAACE,KAAJ,CAAUC;AAAjB,KAAhB,EAAuCI,IAAvC,EAAtB;;AACA,QAAIH,OAAJ,EAAa;AACX,aAAOH,GAAG,CAACO,IAAJ,CAASJ,OAAT,CAAP;AACD;AACF;;AACD,QAAMK,QAAQ,GAAG,MAAMX,OAAO,CAACY,IAAR,GAAeC,QAAf,CAAwB,UAAxB,EAAoCJ,IAApC,EAAvB;AACA,SAAON,GAAG,CAACO,IAAJ,CAASC,QAAT,CAAP;AACD,CAVyB,CAA1B","sourcesContent":["import withSession from \"../../lib/session\";\r\n\r\nimport mongoose from \"mongoose\";\r\n\r\nconst ProductSchema = new mongoose.Schema({\r\n  name: { type: String, required: true, unique: true },\r\n  category: { type: mongoose.SchemaTypes.ObjectId, ref: \"Category\" },\r\n  brand: String,\r\n  image: String,\r\n  price: Number,\r\n  rating: Number,\r\n  numReviews: Number,\r\n  countInStock: Number,\r\n});\r\n\r\nmongoose.connect(\r\n  \"mongodb+srv://komsomolradio:irkytsk87@cluster0.melez.gcp.mongodb.net/vercel-amazemo?retryWrites=true&w=majority\",\r\n  {\r\n    useNewUrlParser: true,\r\n    useUnifiedTopology: true,\r\n    useFindAndModify: false,\r\n  }\r\n);\r\n\r\nlet Product;\r\n\r\ntry {\r\n  // Trying to get the existing model to avoid OverwriteModelError\r\n\r\n  Product = mongoose.model(\"Product\");\r\n} catch {\r\n  Product = mongoose.model(\"Product\", ProductSchema);\r\n}\r\n\r\nexport default withSession(async (req, res) => {\r\n  if (req.query.id) {\r\n    // const product = data.products.find((x) => x._id == req.query.id);\r\n    const product = await Product.findOne({ _id: req.query.id }).lean();\r\n    if (product) {\r\n      return res.json(product);\r\n    }\r\n  }\r\n  const products = await Product.find().populate(\"category\").lean();\r\n  return res.json(products);\r\n});\r\n"]},"metadata":{},"sourceType":"module"}